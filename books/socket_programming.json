[
  {
    "n": 1,
    "title": "Introduction to C Programming and Integer Arithmetic",
    "math": "Integer Arithmetic",
    "note": "Introduce fundamental C programming concepts, basic syntax, data types (int, char, float, double), variable declaration, input/output, and control structures. Provide hands-on exercises with integer arithmetic (addition, subtraction, multiplication, division, modulus) in C. Teach mathematical foundations by manually computing and verifying arithmetic operations and examining integer overflow and underflow, discussing their significance in low-level programming."
  },
  {
    "n": 2,
    "title": "The C Memory Model and Pointer Arithmetic",
    "math": "Integer Arithmetic",
    "note": "Explain the memory layout of a C program and the role of pointers in managing memory. Demonstrate how pointers reference memory locations and how pointer arithmetic enables navigation through arrays and data structures. Use practical exercises to teach integer arithmetic in pointer manipulation, such as incrementing, decrementing, and finding the difference between pointers. Instruct on the mathematical implications of pointer calculations, datatype sizes, and address computation."
  },
  {
    "n": 3,
    "title": "Introduction to Computer Networks and Binary Addressing",
    "math": "Binary Representation",
    "note": "Explain the basics of digital networking, IP addresses, ports, and binary addressing. Teach students how IP addresses (IPv4) are represented in binary and how subnets and masks work. Provide exercises in converting IP addresses between decimal and binary, and demonstrate how binary math is critical in network calculations and partitioning."
  },
  {
    "n": 4,
    "title": "OSI Model and TCP/IP Architecture",
    "math": "Graph Theory",
    "note": "Teach the seven layers of the OSI model and the four layers of the TCP/IP model. Utilize graph theory to visualize how data propagates through network layers and nodes, with each layer and device as a node and dataflow as edges. Access real-world analogies to illustrate the modular and hierarchical nature of protocol stacks."
  },
  {
    "n": 5,
    "title": "TCP vs UDP: Message Boundaries and Reliability",
    "math": "Boolean Algebra",
    "note": "Distinguish between TCP (connection-oriented, reliable, stream-based) and UDP (connectionless, best-effort, packet-based) sockets. Use Boolean expressions to teach how flags and protocol options encode and control connection states. Illustrate, on a per-bit basis, how TCP headers use flag bits for handshake and control."
  },
  {
    "n": 6,
    "title": "Core Socket API: socket(), bind(), listen(), accept()",
    "math": "Function Mapping",
    "note": "Introduce the core server-side socket functions. Explain socket() for creating an endpoint, bind() for assigning an address, listen() for enabling connection acceptance, and accept() for handling new clients. Model these as a sequence of functions mapping system resources to a final, connected socket descriptor."
  },
  {
    "n": 7,
    "title": "Core Socket API: connect(), send(), recv()",
    "math": "Integer Arithmetic",
    "note": "Cover the client-side connect() call and the data transfer functions send() and recv(). Reinforce buffer management, specifying buffer size, and pointer arithmetic for buffer navigation. Use integer arithmetic to teach buffer sizing, offset management, and calculation of actual data transferred."
  },
  {
    "n": 8,
    "title": "Endianness and Network Byte Order",
    "math": "Base Conversion",
    "note": "Teach the necessity of converting host to network byte order using htons(), htonl(), ntohs(), and ntohl(). Clarify the difference between little-endian and big-endian formats and its importance for protocol compliance and cross-platform compatibility."
  },
  {
    "n": 9,
    "title": "Graceful Connection Shutdown with shutdown() and close()",
    "math": "State Machines",
    "note": "Explain the importance of releasing resources with close(). Introduce shutdown() to signal the end of writing while allowing remaining data to be read. Model the TCP FIN/ACK exchange as a state machine transition, contrasting a full close with a half-close."
  },
  {
    "n": 10,
    "title": "Building a Basic TCP Server",
    "math": "Sequence and Order",
    "note": "Present a step-by-step example implementing a TCP server using socket(), bind(), listen(), accept(), recv(), send(), and close(). Emphasize the logical and mathematical sequence required for correct execution, and model the process as an ordered set of operations."
  },
  {
    "n": 11,
    "title": "Building a Basic TCP Client",
    "math": "Inverse Functions",
    "note": "Guide through the construction of a simple TCP client using socket(), connect(), send(), recv(), and close(). Compare and contrast the flow of the client with the server, modeling the client’s actions as inverse functions of the server’s."
  },
  {
    "n": 12,
    "title": "UDP Sockets: sendto() and recvfrom()",
    "math": "Set Theory",
    "note": "Introduce connectionless programming with UDP. Demonstrate the use of sendto() and recvfrom() to send and receive datagrams without an established connection. Use set theory to describe the set of potential recipients (broadcast/multicast) or senders."
  },
  {
    "n": 13,
    "title": "Blocking vs Non-Blocking Sockets",
    "math": "Finite State Machines",
    "note": "Teach blocking and non-blocking socket operation modes. Model the IO operation and socket states as states in a finite state machine. Demonstrate how to configure sockets to be non-blocking with fcntl() and handle EAGAIN/EWOULDBLOCK errors in an event-driven design."
  },
  {
    "n": 14,
    "title": "I/O Multiplexing with select() and poll()",
    "math": "Boolean Logic and Set Operations",
    "note": "Cover the use of select() and poll() for monitoring multiple sockets simultaneously. Teach about fd_set and pollfd arrays, mapping their membership and readiness with set and Boolean logic. Build a server that can handle multiple clients without threads."
  },
  {
    "n": 15,
    "title": "High-Performance I/O with epoll (Linux)",
    "math": "Graph Theory (Event Graphs)",
    "note": "Introduce epoll as a modern, scalable alternative to select()/poll(). Explain its advantages, including edge-triggered notifications (ET) and efficient O(1) dispatch. Model the epoll interest list as a directed graph of file descriptors and events."
  },
  {
    "n": 16,
    "title": "Configuring Sockets with setsockopt()",
    "math": "Boolean Algebra",
    "note": "Demonstrate how to manipulate socket behavior using setsockopt(). Cover key options like SO_REUSEADDR (address reuse), SO_KEEPALIVE (detecting dead peers), and TCP_NODELAY (disabling Nagle's algorithm). Use Boolean logic to enable/disable flags."
  },
  {
    "n": 17,
    "title": "IPC with Unix Domain Sockets",
    "math": "Function Composition",
    "note": "Explain Inter-Process Communication using Unix Domain Sockets, which use the filesystem for addressing instead of IP/ports. Show how the standard socket API is composed with a different address family (AF_UNIX) to achieve efficient on-machine communication."
  },
  {
    "n": 18,
    "title": "Securing Sockets with SSL/TLS (using OpenSSL)",
    "math": "Cryptography and Layering",
    "note": "Introduce the fundamentals of Transport Layer Security (TLS) for encrypting communications. Provide a high-level overview of using a library like OpenSSL to wrap an existing TCP socket, layering security between the application protocol and the transport layer."
  },
  {
    "n": 19,
    "title": "Multi-threaded Socket Programming",
    "math": "Concurrency Models",
    "note": "Introduce multithreaded server design with POSIX Threads (pthreads). Cover the creation and management of threads in a 'thread-per-client' model. Discuss the challenges of concurrency, including race conditions and the need for synchronization."
  },
  {
    "n": 20,
    "title": "Synchronization with Mutexes",
    "math": "Synchronization and Event Timing",
    "note": "Demonstrate thread synchronization techniques, focusing on mutexes to protect shared data from race conditions. Analyze thread schedules and event timing mathematically to show how mutexes prevent data corruption in concurrent servers."
  },
  {
    "n": 21,
    "title": "Troubleshooting and Error Handling",
    "math": "Probability and Error Analysis",
    "note": "Introduce robust error handling for socket programming, focusing on checking return values, inspecting the errno variable, and using perror() or strerror(). Discuss common network errors and their probability in different scenarios."
  }
]

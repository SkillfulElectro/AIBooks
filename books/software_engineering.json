[
  {
    "n": 1,
    "title": "Introduction to Software Engineering",
    "math": "Problem decomposition",
    "note": "This section defines Software Engineering as a discipline. It explains the key differences between simple programming and a systematic engineering approach to software development, emphasizing the importance of reliability, scalability, and maintainability for building complex systems."
  },
  {
    "n": 2,
    "title": "The Software Development Life Cycle (SDLC)",
    "math": "Process flow models",
    "note": "An introduction to the Software Development Life Cycle (SDLC), a foundational framework for software development. This lesson provides an overview of the core phases: Requirements gathering, Design, Implementation (Coding), Testing, Deployment, and Maintenance. The context is a structured approach to building software."
  },
  {
    "n": 3,
    "title": "Classic SDLC Models: Waterfall, V-Model, Spiral",
    "math": "Linear vs. iterative models",
    "note": "This section explores traditional, plan-driven SDLC models. It details the linear-sequential Waterfall model, the V-Model (which emphasizes testing), the Incremental model (delivering parts of the system in increments), and the risk-driven Spiral model. The pros and cons of each approach are discussed."
  },
  {
    "n": 4,
    "title": "Agile Methodologies: Scrum and Kanban",
    "math": "Empirical process control",
    "note": "This lesson introduces the principles of the Agile Manifesto. It provides a detailed explanation of Scrum, including its roles (Product Owner, Scrum Master, Development Team), events (Sprint, Daily Stand-up), and artifacts (Product Backlog, Sprint Backlog). It also introduces Kanban as a visual method for managing workflow."
  },
  {
    "n": 5,
    "title": "The Secure SDLC (SSDLC)",
    "math": "Risk analysis models",
    "note": "Introduces the Secure Software Development Life Cycle, integrating security practices into the SDLC. Covers key concepts like threat modeling (e.g., STRIDE), security requirements, and the principle of 'shifting left' to find and fix vulnerabilities early."
  },
  {
    "n": 6,
    "title": "Requirements Engineering",
    "math": "Formal logic",
    "note": "Learn how to gather and manage software requirements. This section distinguishes between Functional (what the system does) and Non-functional (how the system performs) requirements. Techniques for eliciting requirements, such as interviews, surveys, and user stories, are explained."
  },
  {
    "n": 7,
    "title": "Software Architecture Styles",
    "math": "Graph theory, network topology",
    "note": "An introduction to high-level software structures. This section compares and contrasts major architectural styles: the traditional, tightly-coupled Monolithic architecture, the independently deployable Microservices architecture, and the distributed Service-Oriented Architecture (SOA)."
  },
  {
    "n": 8,
    "title": "Core Software Design Principles (SOLID, DRY, KISS)",
    "math": "Object-oriented design principles",
    "note": "This lesson covers fundamental principles for writing clean, maintainable code. It explains the SOLID principles (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion), as well as DRY (Don't Repeat Yourself) and KISS (Keep It Simple, Stupid)."
  },
  {
    "n": 9,
    "title": "Introduction to Design Patterns",
    "math": "Pattern recognition",
    "note": "Explores Design Patterns as reusable solutions to common software design problems. Introduces the three main categories (Creational, Structural, Behavioral) with examples like the Factory, Singleton, Adapter, and Observer patterns."
  },
  {
    "n": 10,
    "title": "API Design Principles (REST)",
    "math": "Interface theory",
    "note": "Covers the fundamentals of designing Application Programming Interfaces (APIs). Focuses on REST (Representational State Transfer) principles, including resource-based URLs, standard HTTP methods (GET, POST, PUT, DELETE), and the use of JSON for data exchange."
  },
  {
    "n": 11,
    "title": "Introduction to UML Diagrams",
    "math": "Visual modeling languages",
    "note": "This lesson introduces the Unified Modeling Language (UML) as a standard way to visualize a system's design. It provides an overview of three common diagram types: Use Case diagrams (for user interactions), Class diagrams (for static structure), and Sequence diagrams (for object interactions over time)."
  },
  {
    "n": 12,
    "title": "Collaborative Version Control with Git",
    "math": "Directed acyclic graphs (DAGs)",
    "note": "Explains the critical role of version control. Covers Git basics (`commit`, `log`) and expands to collaborative workflows, including branching (`branch`, `checkout`), merging (`merge`), and the pull/merge request process for team-based development."
  },
  {
    "n": 13,
    "title": "Foundations of Software Testing",
    "math": "Combinatorics, equivalence partitioning",
    "note": "An introduction to the principles of software testing. This lesson explains the different levels of testing: Unit Testing (code-level), Integration Testing (component interaction), System Testing (end-to-end), and User Acceptance Testing (UAT). It also defines the difference between Black-Box and White-Box testing techniques."
  },
  {
    "n": 14,
    "title": "Software Quality Assurance (SQA)",
    "math": "Statistical analysis",
    "note": "This lesson defines Software Quality Assurance (SQA) as a process-oriented activity. It explains how SQA ensures quality throughout the SDLC using methods like establishing coding standards, conducting formal code reviews (peer reviews), and using static analysis tools to automatically detect potential issues in the source code."
  },
  {
    "n": 15,
    "title": "Refactoring and Technical Debt",
    "math": "Complexity analysis",
    "note": "Introduces refactoring as the process of improving code's internal structure without changing its external behavior. Defines Technical Debt as the implied cost of rework caused by choosing an easy solution now instead of using a better approach that would take longer."
  },
  {
    "n": 16,
    "title": "Software Metrics and Measurement",
    "math": "Statistical measurement",
    "note": "Explores how to measure software products and processes. Covers key code quality metrics (e.g., Cyclomatic Complexity, Code Coverage) and process metrics used in Agile/DevOps (e.g., Lead Time, Cycle Time, Defect Density)."
  },
  {
    "n": 17,
    "title": "Continuous Integration & Deployment (CI/CD)",
    "math": "Automation and pipeline logic",
    "note": "This lesson introduces the concept of CI/CD as a cornerstone of modern DevOps practices. It explains how Continuous Integration (CI) involves automatically building and testing code changes, and how Continuous Deployment (CD) automates the release of validated code to a production environment. The goal of a CI/CD pipeline is explained."
  },
  {
    "n": 18,
    "title": "Software Project Management Basics",
    "math": "Estimation theory, probability",
    "note": "This section covers fundamental concepts in managing software projects. It introduces techniques for effort estimation, such as Story Points used in Agile teams. It also provides an overview of project scheduling, resource allocation, and basic risk management (identifying and mitigating potential problems)."
  },
  {
    "n": 19,
    "title": "Software Maintenance",
    "math": "System lifecycle analysis",
    "note": "This section explores the post-deployment phase of the SDLC. It defines the four categories of software maintenance: Corrective (fixing bugs), Adaptive (modifying the system to cope with a changed environment), Perfective (implementing new user requirements), and Preventive (making software more maintainable)."
  },
  {
    "n": 20,
    "title": "Technical Documentation",
    "math": "Information architecture",
    "note": "Covers the importance and types of technical documentation in software engineering. Discusses API documentation (e.g., using OpenAPI/Swagger), system architecture diagrams, and user guides. Emphasizes writing for the intended audience."
  }
]

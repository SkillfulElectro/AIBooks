[
  {
    "n": 1,
    "title": "Introduction to Swift",
    "math": "Programming languages",
    "note": "Introduces Swift as a modern, fast, safe, and expressive language from Apple. Covers its use cases for iOS, macOS, etc., and setting up the environment with Xcode and Playgrounds."
  },
  {
    "n": 2,
    "title": "Basic Syntax: Constants, Variables, and Type Inference",
    "math": "Immutability & Type systems",
    "note": "Covers declaring constants with `let` and variables with `var`. Explains Swift's type safety and how the compiler uses type inference to determine types automatically."
  },
  {
    "n": 3,
    "title": "Collection Types: Arrays, Sets, and Dictionaries",
    "math": "Collection data structures",
    "note": "Covers the three primary collection types in Swift: Arrays (ordered), Sets (unordered, unique), and Dictionaries (unordered key-value pairs)."
  },
  {
    "n": 4,
    "title": "Control Flow: `if`, `switch`, and `for-in` Loops",
    "math": "Conditional logic & Iteration",
    "note": "Covers conditional logic with `if/else` and the powerful, exhaustive `switch` statement. Also covers iterating over sequences with `for-in` loops."
  },
  {
    "n": 5,
    "title": "Handling Absence of Value: Optionals",
    "math": "Nullable types (Optionals)",
    "note": "Introduces one of Swift's most important safety features. An optional type holds either a value or `nil`, forcing the programmer to safely handle potential nulls."
  },
  {
    "n": 6,
    "title": "Safely Unwrapping Optionals",
    "math": "Optional binding",
    "note": "Demonstrates safe ways to work with optionals, including optional binding (`if let`, `guard let`), the nil-coalescing operator (`??`), and optional chaining."
  },
  {
    "n": 7,
    "title": "Functions and Closures",
    "math": "Functions & Closures (lambdas)",
    "note": "Covers defining functions with `func`. Introduces closures as self-contained blocks of functionality, and their use with higher-order functions like `map`, `filter`, and `reduce`."
  },
  {
    "n": 8,
    "title": "Custom Types: Structures and Classes",
    "math": "Value types vs. reference types",
    "note": "Contrasts Structures (`struct`), which are value types (copied), and Classes (`class`), which are reference types (shared). Emphasizes the preference for structs for safety."
  },
  {
    "n": 9,
    "title": "Properties and Methods",
    "math": "Instance members",
    "note": "Covers defining stored properties and methods on structs and classes. Explains the difference between instance members and type-level (static) members."
  },
  {
    "n": 10,
    "title": "Modeling State with Enums",
    "math": "Enumerated types with associated values",
    "note": "Explores Swift's powerful enumerations. Covers defining cases and using associated values to store additional, type-safe information with each case, enabling robust state modeling."
  },
  {
    "n": 11,
    "title": "Protocols and Protocol-Oriented Programming",
    "math": "Protocols (interfaces)",
    "note": "Introduces Protocols as blueprints of functionality. Explains how types can 'conform' to protocols, a core concept in Swift's protocol-oriented programming paradigm."
  },
  {
    "n": 12,
    "title": "Extending Existing Types with Extensions",
    "math": "Extensions",
    "note": "Covers Extensions, which allow you to add new functionality (methods, computed properties, protocol conformance) to existing types, even those from the standard library."
  },
  {
    "n": 13,
    "title": "Generics",
    "math": "Generics",
    "note": "Explains how to write flexible, reusable functions and types that can work with any type. Covers creating generic functions and custom generic types to avoid code duplication."
  },
  {
    "n": 14,
    "title": "Error Handling with `do-catch`",
    "math": "Error handling",
    "note": "Explains Swift's error handling model. Covers creating custom errors, throwing errors with `throw`, and handling them with a `do-catch` statement or propagating them with `throws`."
  },
  {
    "n": 15,
    "title": "Memory Management: ARC and Reference Cycles",
    "math": "Automatic Reference Counting (ARC)",
    "note": "Explains how Swift uses Automatic Reference Counting to manage memory. Crucially, it covers how to resolve strong reference cycles (memory leaks) using `weak` and `unowned` references."
  },
  {
    "n": 16,
    "title": "Concurrency: `async` and `await`",
    "math": "Asynchronous programming",
    "note": "Introduces Swift's modern concurrency model. Explains how to define and call asynchronous functions with `async` and `await`, allowing complex operations to run without blocking the UI."
  },
  {
    "n": 17,
    "title": "Safe Concurrent State with Actors",
    "math": "Actor model",
    "note": "Introduces Actors as a special kind of type that protects its state from concurrent access. Explains how actors prevent data races by ensuring only one operation can access their state at a time."
  },
  {
    "n": 18,
    "title": "Managing Dependencies with Swift Package Manager",
    "math": "Dependency management",
    "note": "Covers the Swift Package Manager (SPM), the official tool for integrating third-party libraries into your project. Demonstrates how to add a package dependency in Xcode."
  },
  {
    "n": 19,
    "title": "Introduction to SwiftUI",
    "math": "Declarative UI frameworks",
    "note": "Provides a high-level introduction to SwiftUI, Apple's modern, declarative framework for building user interfaces. Explains how to describe a UI based on its state."
  },
  {
    "n": 20,
    "title": "Building a Simple SwiftUI View",
    "math": "UI composition",
    "note": "Provides a 'Hello, World!' example in SwiftUI. Demonstrates creating a `View` and combining basic views like `Text`, `Image`, and layout containers like `VStack` and `HStack`."
  }
]

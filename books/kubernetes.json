[
  {
    "n": 1,
    "title": "Introduction to Containers and Orchestration",
    "math": "Abstraction",
    "note": "This lesson introduces containerization (using Docker as an example) and explains why a container orchestrator is needed to manage applications at scale. It covers challenges like deployment, scaling, and self-healing, which Kubernetes is designed to solve."
  },
  {
    "n": 2,
    "title": "Kubernetes Architecture",
    "math": "Distributed systems",
    "note": "A deep dive into the Kubernetes architecture. It covers the components of the Control Plane (API Server, etcd, Scheduler, Controller Manager) and the Worker Nodes (Kubelet, Kube-proxy, Container Runtime), explaining the role of each."
  },
  {
    "n": 3,
    "title": "Setting Up a Kubernetes Environment",
    "math": "System setup",
    "note": "This lesson guides you through setting up a local Kubernetes cluster using tools like Minikube or Docker Desktop. It also introduces `kubectl`, the essential command-line tool for interacting with a Kubernetes cluster."
  },
  {
    "n": 4,
    "title": "Core Object: Pods",
    "math": "Atomic units",
    "note": "This lesson explains the Pod, the smallest deployable unit in Kubernetes. It discusses why Pods are necessary and how they can contain one or more containers that share storage and network resources. Creating a Pod with a YAML manifest is demonstrated."
  },
  {
    "n": 5,
    "title": "Pod Lifecycle and Health Checks",
    "math": "State machines",
    "note": "This lesson covers the lifecycle of a Pod (Pending, Running, Succeeded, Failed). It also introduces liveness, readiness, and startup probes for monitoring the health of applications running in Pods to enable self-healing."
  },
  {
    "n": 6,
    "title": "Workload: Deployments",
    "math": "Declarative configuration",
    "note": "This lesson introduces Deployments for managing stateless applications. It explains how a Deployment declaratively manages a set of identical Pods via a ReplicaSet, providing self-healing and the ability to scale."
  },
  {
    "n": 7,
    "title": "Managing Application Updates with Deployments",
    "math": "Rolling updates",
    "note": "This lesson shows how Deployments manage application updates. It explains the 'rolling update' strategy, which updates Pods incrementally with zero downtime, and how to roll back to a previous version if something goes wrong."
  },
  {
    "n": 8,
    "title": "Networking: Services",
    "math": "Service discovery",
    "note": "This lesson explains how Services provide a stable network endpoint for a set of Pods. It discusses the different types of Services (ClusterIP, NodePort, LoadBalancer) and how they enable communication between different parts of your application using labels and selectors."
  },
  {
    "n": 9,
    "title": "Networking: Ingress",
    "math": "HTTP routing",
    "note": "This lesson explains how Ingress manages external HTTP/S access to services in a cluster. It discusses how an Ingress Controller (like NGINX) uses Ingress rules to provide load balancing, SSL termination, and name-based virtual hosting."
  },
  {
    "n": 10,
    "title": "Configuration: ConfigMaps and Secrets",
    "math": "Key-value stores",
    "note": "This lesson explains how to decouple configuration from application code. It covers ConfigMaps for non-sensitive configuration data and Secrets for sensitive data like passwords and API keys, and how to inject them into Pods."
  },
  {
    "n": 11,
    "title": "Storage: Volumes",
    "math": "Data persistence",
    "note": "This lesson introduces Volumes as a way to provide storage for containers that persists beyond the life of a single Pod. It covers different volume types, such as `emptyDir` for temporary space and host-backed volumes."
  },
  {
    "n": 12,
    "title": "Storage: PersistentVolumes and PersistentVolumeClaims",
    "math": "Storage abstraction",
    "note": "This lesson explains the PV and PVC subsystems, which decouple storage provisioning from consumption. A PersistentVolume (PV) is a piece of storage provisioned by an admin. A PersistentVolumeClaim (PVC) is a request for storage by a user, which gets bound to a PV."
  },
  {
    "n": 13,
    "title": "Storage: StorageClasses",
    "math": "Dynamic provisioning",
    "note": "This lesson introduces StorageClasses for automatic, dynamic provisioning of PersistentVolumes. It explains how a StorageClass can be used to create storage on-demand from a cloud provider, without manual intervention from an administrator."
  },
  {
    "n": 14,
    "title": "Workload: StatefulSets",
    "math": "Ordinal indices",
    "note": "This lesson introduces StatefulSets for managing stateful applications (like databases) that require stable, unique network identifiers and stable, persistent storage. It contrasts their behavior with Deployments."
  },
  {
    "n": 15,
    "title": "Workload: DaemonSets",
    "math": "Set theory",
    "note": "This lesson explains how to use DaemonSets to run a copy of a Pod on all (or some) nodes in a cluster. This is used for cluster-level services like log collectors and monitoring agents."
  },
  {
    "n": 16,
    "title": "Workload: Jobs and CronJobs",
    "math": "Scheduling algorithms",
    "note": "This lesson introduces Jobs for running finite tasks to completion, and CronJobs for running jobs on a time-based schedule. This is used for batch processing and other non-continuous workloads."
  },
  {
    "n": 17,
    "title": "Resource Management: Requests and Limits",
    "math": "Resource allocation",
    "note": "A dedicated lesson on managing compute resources. It explains the critical difference between setting CPU/Memory requests (which guarantees a minimum for scheduling) and limits (which enforces a maximum to prevent resource starvation)."
  },
  {
    "n": 18,
    "title": "Scheduling: Taints, Tolerations, and Affinity",
    "math": "Advanced scheduling",
    "note": "A lesson on the advanced scheduling features. It explains Taints and Tolerations (to repel pods from certain nodes) and Node Affinity/Anti-Affinity (to attract or repel pods from nodes with specific labels), giving administrators fine-grained control over pod placement."
  },
  {
    "n": 19,
    "title": "Security: Role-Based Access Control (RBAC)",
    "math": "Access control matrices",
    "note": "This lesson introduces RBAC for regulating access to the Kubernetes API. You will learn how to define Roles and ClusterRoles (sets of permissions), and how to bind them to users or services using RoleBindings and ClusterRoleBindings."
  },
  {
    "n": 20,
    "title": "Security: Network Policies",
    "math": "Firewall rules",
    "note": "A lesson on the `NetworkPolicy` resource. It explains how network policies are used to control the flow of traffic between pods, acting as a firewall within the cluster. It covers how to create policies that allow or deny traffic based on pod labels."
  },
  {
    "n": 21,
    "title": "Package Management with Helm",
    "math": "Templating engines",
    "note": "This lesson introduces Helm as the package manager for Kubernetes. It explains how to use Helm charts to define, install, and upgrade even the most complex Kubernetes applications, simplifying deployment and management."
  },
  {
    "n": 22,
    "title": "Observability: Monitoring with Prometheus",
    "math": "Time-series data",
    "note": "This lesson introduces Prometheus for monitoring and alerting. You will learn how to deploy Prometheus in your cluster and how it scrapes metrics from your applications and Kubernetes components, providing a foundation for observability."
  },
  {
    "n": 23,
    "title": "Observability: Visualizing with Grafana",
    "math": "Data visualization",
    "note": "This lesson shows how to use Grafana to create dashboards for visualizing the metrics collected by Prometheus. You will learn how to build custom dashboards to get insights into the performance of your cluster and applications."
  },
  {
    "n": 24,
    "title": "Observability: Centralized Logging",
    "math": "Log aggregation",
    "note": "This lesson introduces a common logging solution for Kubernetes, such as the EFK (Elasticsearch, Fluentd, Kibana) stack. You will learn how to deploy a log collection agent to gather, store, and visualize logs from all your pods in a centralized location."
  },
  {
    "n": 25,
    "title": "Extending Kubernetes: CRDs and Operators",
    "math": "API extension, control theory",
    "note": "This lesson explains how to extend the Kubernetes API with Custom Resource Definitions (CRDs) and introduces the Operator pattern for managing complex applications by building custom controllers that encode operational knowledge."
  }
]

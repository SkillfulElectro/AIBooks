[
  {
    "n": 1,
    "title": "Introduction to Data Structures and Algorithms",
    "math": "Computational complexity theory",
    "note": "This section introduces data structures as a way to organize data and algorithms as a set of instructions to solve problems. It covers the importance of efficiency in terms of time and space complexity. The context is a general programming environment (e.g., Python or Java)."
  },
  {
    "n": 2,
    "title": "Algorithm Analysis and Big O Notation",
    "math": "Asymptotic analysis",
    "note": "Explains how to analyze the efficiency of algorithms using Big O notation. The lesson covers how to describe the worst-case, average-case, and best-case performance of an algorithm in terms of its input size. Common complexities like O(1), O(log n), O(n), O(n log n), and O(n^2) are defined."
  },
  {
    "n": 3,
    "title": "Arrays and Linked Lists",
    "math": "Contiguous vs. linked data structures",
    "note": "This lesson introduces and contrasts the two most basic data structures. Arrays provide O(1) random access but have slow insertions/deletions. Linked Lists provide O(1) insertions/deletions at the ends but have O(n) access time. Doubly linked lists are also discussed."
  },
  {
    "n": 4,
    "title": "Stacks and Queues",
    "math": "LIFO vs. FIFO",
    "note": "This lesson covers two fundamental abstract data types. The Stack is a Last-In, First-Out (LIFO) structure with `push` and `pop` operations. The Queue is a First-In, First-Out (FIFO) structure with `enqueue` and `dequeue` operations. Both can be implemented with arrays or linked lists."
  },
  {
    "n": 5,
    "title": "Hash Tables",
    "math": "Hash functions",
    "note": "Explains the hash table data structure for efficient key-value storage and retrieval, with an average time complexity of O(1). The lesson covers hash functions, the concept of collisions, and collision resolution strategies like separate chaining."
  },
  {
    "n": 6,
    "title": "Trees: Terminology and Representation",
    "math": "Tree data structures",
    "note": "This lesson introduces the tree as a hierarchical data structure. It covers basic terminology (root, node, leaf, height, depth) and focuses on the binary tree. Common representations like using nodes with pointers are discussed."
  },
  {
    "n": 7,
    "title": "Tree Traversal Algorithms",
    "math": "Graph theory",
    "note": "Covers the fundamental algorithms for visiting all nodes in a tree: pre-order, in-order, and post-order traversal (which are types of Depth-First Search), and level-order traversal (which is a Breadth-First Search)."
  },
  {
    "n": 8,
    "title": "Binary Search Trees (BSTs)",
    "math": "Set theory",
    "note": "Explains the Binary Search Tree (BST), a sorted tree structure that allows for fast search, insert, and delete operations (average O(log n)). The lesson covers the BST property (left child < parent < right child) and the implementation of its core operations."
  },
  {
    "n": 9,
    "title": "Balanced Binary Search Trees (AVL, Red-Black)",
    "math": "Self-balancing trees",
    "note": "This section introduces self-balancing BSTs, such as AVL trees and Red-Black trees. It explains why balancing is necessary to guarantee O(log n) performance in the worst case by performing rotations to prevent the tree from becoming degenerate."
  },
  {
    "n": 10,
    "title": "Heaps and Priority Queues",
    "math": "Heap property",
    "note": "Explains the heap data structure (specifically, a binary heap), which satisfies the heap property (e.g., in a max-heap, every parent is greater than its children). The lesson demonstrates how heaps are an efficient way to implement priority queues."
  },
  {
    "n": 11,
    "title": "Graphs: Representation and Traversal",
    "math": "Graph theory",
    "note": "This lesson introduces the graph for modeling networks. It covers representations (adjacency matrix, adjacency list) and the two main traversal algorithms: Breadth-First Search (BFS) for shortest path in unweighted graphs, and Depth-First Search (DFS) for exploring branches."
  },
  {
    "n": 12,
    "title": "Introduction to Sorting Algorithms",
    "math": "Sorting algorithms",
    "note": "Provides an overview of sorting. The lesson covers basic, quadratic (O(n^2)) sorting algorithms like Bubble Sort, Selection Sort, and Insertion Sort to build intuition before moving to more efficient methods."
  },
  {
    "n": 13,
    "title": "Efficient Sorting: Merge Sort and Quick Sort",
    "math": "Divide and conquer",
    "note": "This lesson covers the two most important divide-and-conquer sorting algorithms. Merge Sort has a guaranteed O(n log n) performance. Quick Sort has an average-case O(n log n) performance and is often faster in practice due to its in-place nature."
  },
  {
    "n": 14,
    "title": "Searching Algorithms: Linear and Binary Search",
    "math": "Search algorithms",
    "note": "Covers the two basic searching algorithms. Linear Search (O(n)) for unsorted data, and the much more efficient Binary Search (O(log n)), which requires the data to be sorted first."
  },
  {
    "n": 15,
    "title": "Algorithm Design: Recursion",
    "math": "Recursion theory",
    "note": "This section provides a deeper look at recursion as a problem-solving technique where a function calls itself. It covers the concept of a base case and a recursive step, using examples like factorial and linking it back to divide-and-conquer algorithms."
  },
  {
    "n": 16,
    "title": "Algorithm Design: Dynamic Programming",
    "math": "Optimization, overlapping subproblems",
    "note": "Introduces dynamic programming (DP) as a technique for solving complex problems by breaking them down into simpler, overlapping subproblems. It covers the concepts of memoization (top-down) and tabulation (bottom-up) using the Fibonacci sequence as an example."
  },
  {
    "n": 17,
    "title": "Algorithm Design: Greedy Algorithms",
    "math": "Optimization, greedy choice property",
    "note": "Explains the greedy algorithm paradigm, where the algorithm makes the locally optimal choice at each stage with the hope of finding a global optimum. The lesson discusses classic examples like making change with the fewest coins and when the greedy approach works."
  },
  {
    "n": 18,
    "title": "Graph Algorithms: Dijkstra's Shortest Path",
    "math": "Shortest path algorithms",
    "note": "This lesson introduces Dijkstra's algorithm for finding the shortest path from a single source to all other nodes in a weighted graph with non-negative edge weights. It explains how the algorithm works using a priority queue to always explore the next-closest vertex."
  },
  {
    "n": 19,
    "title": "Graph Algorithms: Minimum Spanning Tree (MST)",
    "math": "Minimum spanning trees",
    "note": "This lesson introduces the concept of a Minimum Spanning Tree. It conceptually explains the two main greedy algorithms for finding it: Kruskal's algorithm (which sorts all edges and adds them if they don't form a cycle) and Prim's algorithm (which grows the tree from a single vertex)."
  },
  {
    "n": 20,
    "title": "Graph Algorithms: Topological Sort",
    "math": "Directed acyclic graphs (DAGs)",
    "note": "This lesson covers Topological Sort, an algorithm for Directed Acyclic Graphs (DAGs) that produces a linear ordering of vertices such that for every directed edge from u to v, u comes before v. This is used for scheduling tasks with dependencies."
  },
  {
    "n": 21,
    "title": "Advanced Data Structure: Tries",
    "math": "Prefix trees",
    "note": "This lesson provides an introduction to the Trie (prefix tree), a specialized tree-based data structure for efficient retrieval of keys in a dataset of strings. It's commonly used for autocomplete features and dictionary lookups."
  },
  {
    "n": 22,
    "title": "Advanced Data Structure: Union-Find",
    "math": "Disjoint Set Union (DSU)",
    "note": "This lesson introduces the Union-Find data structure, which is highly efficient at tracking a set of elements partitioned into a number of disjoint subsets. It covers the `find` and `union` operations and key optimizations like path compression."
  },
  {
    "n": 23,
    "title": "Advanced String Algorithm: KMP Search",
    "math": "String searching",
    "note": "This lesson covers the Knuth-Morris-Pratt (KMP) algorithm for efficient string searching. It explains how it cleverly preprocesses the pattern to build a table that avoids re-checking characters after a mismatch, achieving linear time complexity."
  },
  {
    "n": 24,
    "title": "Bit Manipulation Techniques",
    "math": "Bitwise operations",
    "note": "This lesson covers common bitwise tips and tricks used for optimization and problem-solving. It includes techniques for setting/clearing/toggling/checking bits, and other efficient operations using bitwise AND, OR, XOR, and shift operators."
  }
]

[
  {
    "n": 1,
    "title": "Introduction to x86 Assembly",
    "math": "Low-level programming",
    "note": "Defines Assembly Language as a human-readable representation of machine code. Introduces the x86 architecture and the core tools: assembler (NASM), linker (ld), and debugger (GDB)."
  },
  {
    "n": 2,
    "title": "CPU Registers (32-bit)",
    "math": "CPU registers",
    "note": "Introduces the 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI), special-purpose registers (EIP, ESP, EBP), and the EFLAGS register for status flags (ZF, CF)."
  },
  {
    "n": 3,
    "title": "Your First Program (Linux System Calls)",
    "math": "System calls",
    "note": "A 'Hello, World!' example in NASM for Linux. Demonstrates using the `int 0x80` interrupt to make system calls for writing to the console and exiting the program."
  },
  {
    "n": 4,
    "title": "Data Movement and Addressing Modes",
    "math": "Data transfer & Memory addressing",
    "note": "Covers the `MOV` instruction for copying data. Explains addressing modes, including direct (variables) and indirect (using a register as a pointer to memory)."
  },
  {
    "n": 5,
    "title": "Integer Arithmetic and Bitwise Logic",
    "math": "Integer arithmetic & Bitwise operations",
    "note": "Covers basic arithmetic (`ADD`, `SUB`, `INC`, `DEC`) and logical (`AND`, `OR`, `XOR`, `NOT`) instructions for manipulating data in registers."
  },
  {
    "n": 6,
    "title": "Control Flow: Jumps",
    "math": "Conditional branching",
    "note": "Introduces the `CMP` instruction for comparing operands (which sets flags) and the `JMP` (unconditional jump) and conditional jump (`JE`, `JNE`, `JG`, etc.) instructions for controlling program flow."
  },
  {
    "n": 7,
    "title": "The Stack and Function Calls",
    "math": "Stack data structure",
    "note": "Explains the stack, the `PUSH` and `POP` instructions, and how the `CALL` and `RET` instructions use the stack to enable function calls."
  },
  {
    "n": 8,
    "title": "Stack Frames and Calling Conventions",
    "math": "Calling conventions",
    "note": "Details the 'stack frame' (a function's private space on the stack). Explains the `cdecl` calling convention used by C, which dictates how arguments are passed and who cleans up the stack."
  },
  {
    "n": 9,
    "title": "Interfacing with C Library Functions",
    "math": "Language interoperability",
    "note": "Demonstrates how to call a C library function like `printf` from assembly by pushing arguments to the stack according to the `cdecl` convention."
  },
  {
    "n": 10,
    "title": "Data Structures: Arrays and Structs",
    "math": "Data structures",
    "note": "Explains how to represent arrays and structs in the `.data` or `.bss` sections. Demonstrates how to access elements and fields using base addresses and offsets."
  },
  {
    "n": 11,
    "title": "Code Reuse with Macros",
    "math": "Macros",
    "note": "Introduces assembler macros as a way to define reusable, parameterized blocks of code. This is a key technique for reducing repetition and improving the maintainability of assembly programs."
  },
  {
    "n": 12,
    "title": "Floating-Point Instructions (x87 FPU)",
    "math": "Floating-point arithmetic",
    "note": "Introduces the legacy x87 Floating-Point Unit (FPU). Explains its stack-based architecture and instructions like `fld` (load), `fadd` (add), `fmul` (multiply), and `fstp` (store and pop)."
  },
  {
    "n": 13,
    "title": "SIMD Instructions (SSE)",
    "math": "Single Instruction, Multiple Data (SIMD)",
    "note": "Introduces the modern approach to high-performance math: SIMD using the SSE instruction set. Covers the 128-bit XMM registers and instructions for performing parallel operations on multiple floating-point or integer values at once."
  },
  {
    "n": 14,
    "title": "Introduction to 64-bit Assembly (x86-64)",
    "math": "64-bit architecture",
    "note": "Provides an overview of the key differences in 64-bit mode. Introduces the 64-bit registers (RAX, etc.) and the new general-purpose registers (R8-R15)."
  },
  {
    "n": 15,
    "title": "The x86-64 Calling Convention (System V ABI)",
    "math": "64-bit calling conventions",
    "note": "Explains the modern calling convention where the first six integer arguments are passed in registers (RDI, RSI, RDX, RCX, R8, R9) for efficiency, rather than on the stack."
  },
  {
    "n": 16,
    "title": "Interfacing with the Windows API",
    "math": "Application Binary Interface (ABI)",
    "note": "Provides a contrast to Linux system calls by showing how to call a function from the Windows API (e.g., `MessageBoxA` from `user32.dll`). Highlights the different calling convention (stdcall) and linking process."
  },
  {
    "n": 17,
    "title": "Basic Optimization Techniques",
    "math": "Code optimization",
    "note": "Discusses simple strategies for optimizing assembly code, such as choosing efficient instructions (e.g., using `XOR rax, rax` instead of `MOV rax, 0`) and basic loop unrolling."
  },
  {
    "n": 18,
    "title": "Security Context: Introduction to Shellcoding",
    "math": "Payload development",
    "note": "Provides a high-level conceptual overview of shellcode. Explains that it is a small piece of self-contained code used as a payload in exploits, and discusses the challenges of writing it, such as avoiding null bytes and being position-independent."
  }
]

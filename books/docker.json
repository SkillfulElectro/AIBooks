[
  {
    "n": 1,
    "title": "Understanding Containerization vs. Virtualization",
    "math": "Set Theory, Abstraction",
    "note": "Explain the core concept of containerization as a lightweight OS-level virtualization method. Contrast containers with traditional virtual machines (VMs), focusing on resource efficiency by sharing the host OS kernel versus running a full guest OS. Use the 'shipping container' analogy for portable software packaging."
  },
  {
    "n": 2,
    "title": "Installing Docker",
    "math": "System Configuration",
    "note": "Provide step-by-step instructions for downloading and installing Docker Desktop on Windows and macOS, or Docker Engine on Linux. After installation, verify that the Docker daemon is running by executing `docker --version` and `docker run hello-world` to confirm a successful setup."
  },
  {
    "n": 3,
    "title": "Images and Containers",
    "math": "Instantiation",
    "note": "Define the two core concepts. An Image is a read-only template containing the application and its dependencies. A Container is a live, runnable instance of an image. Explain that you can run many containers from a single image."
  },
  {
    "n": 4,
    "title": "Finding and Pulling Images from Docker Hub",
    "math": "Data Retrieval, Namespacing",
    "note": "Teach how to download pre-built images from Docker Hub. Demonstrate the `docker pull <image>:<tag>` command, explaining image names (e.g., `ubuntu`) and version tags (e.g., `22.04`). Use the `docker images` command to list local images."
  },
  {
    "n": 5,
    "title": "Running Your First Container",
    "math": "Process Management",
    "note": "Use the `docker run <image>` command to start a container. Differentiate between interactive mode (`-it`) for running a shell (e.g., `docker run -it ubuntu bash`) and detached mode (`-d`) for running background services. Use `docker ps` to view running containers."
  },
  {
    "n": 6,
    "title": "The Container Lifecycle",
    "math": "State Machines, Process Control",
    "note": "Teach the essential commands for managing container states. Cover `docker ps -a` to list all containers. Demonstrate `docker stop`, `docker start`, `docker restart`, and `docker rm` to fully manage the container lifecycle."
  },
  {
    "n": 7,
    "title": "Writing a Basic Dockerfile",
    "math": "Scripting, Declarative Instructions",
    "note": "Introduce the Dockerfile as a script of instructions for building a custom image. Teach the fundamental instructions: `FROM` (base image), `WORKDIR` (set working directory), `COPY` (add local files), `RUN` (execute build commands), and `CMD` (default container command)."
  },
  {
    "n": 8,
    "title": "Building an Image from a Dockerfile",
    "math": "Compilation, Dependency Resolution",
    "note": "Demonstrate the `docker build -t <your_image_name>:<tag> .` command. Explain the `-t` flag for tagging the image and the `.` to specify the build context (the current directory). Verify the image was created using `docker images`."
  },
  {
    "n": 9,
    "title": "Optimizing the Build Context with `.dockerignore`",
    "math": "Set exclusion",
    "note": "Introduce the `.dockerignore` file. Explain how it works like `.gitignore` to exclude files (e.g., `.git`, `node_modules`, local secrets) from the build context sent to the Docker daemon. This improves build speed, reduces image size, and enhances security."
  },
  {
    "n": 10,
    "title": "Exposing and Publishing Container Ports",
    "math": "Network Address Translation, Port Forwarding",
    "note": "Explain how to make a service running inside a container accessible from the host machine. Use the `-p` or `--publish` flag in the `docker run` command (e.g., `docker run -p 8080:80 nginx`) to map a host port to a container port."
  },
  {
    "n": 11,
    "title": "Persisting Data with Named Volumes",
    "math": "State Persistence",
    "note": "Introduce the problem of data loss when a container is removed. Explain how named volumes provide a Docker-managed mechanism for persisting data. Demonstrate creating and attaching a volume using the `-v my-data:/path/in/container` flag."
  },
  {
    "n": 12,
    "title": "Using Bind Mounts for Development",
    "math": "File System Mapping",
    "note": "Explain bind mounts as a way to map a file or directory from the host machine directly into a container. Emphasize their utility in development for live code reloading without rebuilding the image. Demonstrate using the `-v /path/on/host:/path/in/container` syntax."
  },
  {
    "n": 13,
    "title": "Docker Networking Fundamentals",
    "math": "Network Topologies",
    "note": "Describe the default `bridge` network. Explain how containers on the same user-defined bridge network can communicate using their container names as DNS hostnames. Demonstrate this by creating a network with `docker network create`."
  },
  {
    "n": 14,
    "title": "Introducing Docker Compose",
    "math": "Declarative Configuration",
    "note": "Introduce Docker Compose as a tool for defining and running multi-container applications using a single YAML file (`docker-compose.yml`). Create a simple YAML file defining two services (e.g., a web app and a database), a shared network, and a volume."
  },
  {
    "n": 15,
    "title": "Managing Stacks with Docker Compose",
    "math": "Command and Control",
    "note": "Teach the essential Docker Compose commands: `docker-compose up -d` to start services, `docker-compose ps` to view status, `docker-compose logs` to view output, `docker-compose exec` to run commands, and `docker-compose down` to stop and remove all resources."
  },
  {
    "n": 16,
    "title": "Optimizing Builds with Layer Caching",
    "math": "Caching Algorithms",
    "note": "Explain how Docker uses layer caching to accelerate builds. Teach how to structure a Dockerfile to maximize cache hits by ordering instructions from least to most frequently changing (e.g., install dependencies before copying source code)."
  },
  {
    "n": 17,
    "title": "Creating Small Images with Multi-Stage Builds",
    "math": "Set Operations, Reduction",
    "note": "Introduce multi-stage builds as a technique for creating lean, production-ready images. Show how to compile an application in a 'builder' stage, and then `COPY` only the necessary compiled artifacts into a minimal final runtime stage."
  },
  {
    "n": 18,
    "title": "Understanding `ENTRYPOINT` vs. `CMD`",
    "math": "Function Composition",
    "note": "Clarify the distinct roles of `ENTRYPOINT` and `CMD`. Explain that `ENTRYPOINT` configures a container to run as an executable, while `CMD` provides default arguments to that executable. Demonstrate the recommended 'exec' form (e.g., `ENTRYPOINT [\"python\", \"app.py\"]`)."
  },
  {
    "n": 19,
    "title": "Container Health Checks",
    "math": "System health monitoring",
    "note": "Introduce the `HEALTHCHECK` instruction in a Dockerfile. Explain how it allows you to define a command that Docker can run periodically to check if a container is not just running, but is actually healthy and able to handle traffic. This is crucial for orchestrators."
  },
  {
    "n": 20,
    "title": "Working with Container Registries",
    "math": "Version Control, Data Distribution",
    "note": "Explain the role of a container registry for storing and sharing Docker images. Demonstrate how to log in (`docker login`), tag an image for a repository (`docker tag`), and publish it (`docker push`)."
  },
  {
    "n": 21,
    "title": "Security: Scanning Images for Vulnerabilities",
    "math": "Risk Analysis",
    "note": "Introduce the importance of container image security. Demonstrate the `docker scan` command, which uses an integrated scanner to analyze an image for known vulnerabilities (CVEs) in its OS packages and application dependencies."
  },
  {
    "n": 22,
    "title": "Security: Rootless Mode and Linting",
    "math": "Security hardening",
    "note": "A lesson on security best practices. It introduces the security risks of the Docker daemon running as root and explains the concept of 'Rootless mode' as a modern solution. It also introduces using a linter (like `hadolint`) to statically analyze a Dockerfile for bad practices."
  },
  {
    "n": 23,
    "title": "Limiting Container Resources",
    "math": "Resource Allocation",
    "note": "Explain how to constrain the CPU and memory a container can consume. Demonstrate the `--memory` and `--cpus` flags in `docker run`. Use the `docker stats` command to monitor the real-time resource usage of running containers."
  },
  {
    "n": 24,
    "title": "Managing Container Logs",
    "math": "Data Streaming",
    "note": "Teach how to access the logs generated by a container using the `docker logs` command. Demonstrate the `-f` flag to stream logs in real-time and briefly explain logging drivers for sending logs to external systems."
  },
  {
    "n": 25,
    "title": "Introduction to Container Orchestration",
    "math": "Distributed Systems",
    "note": "Present a conceptual overview of the challenges of running stateful, scalable applications in production (e.g., high availability, load balancing, service discovery). Introduce orchestrators, primarily Kubernetes and Docker Swarm, as tools designed to solve these problems."
  },
  {
    "n": 26,
    "title": "Deploying Services with Docker Swarm",
    "math": "Replication, Fault Tolerance",
    "note": "Introduce Docker Swarm as Docker's native orchestration tool. Demonstrate how to initialize a swarm (`docker swarm init`) and deploy a replicated, load-balanced service (`docker service create`)."
  },
  {
    "n": 27,
    "title": "Using Docker in a CI/CD Pipeline",
    "math": "Automation",
    "note": "Explain how Docker is a cornerstone of modern CI/CD workflows. Outline the typical steps: a CI server builds a Docker image, pushes it to a registry, and then a CD server deploys the new version of the container to production."
  }
]

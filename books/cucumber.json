[
  {
    "n": 1,
    "title": "Introduction to Behavior-Driven Development (BDD)",
    "math": "Software development methodologies",
    "note": "This section introduces Behavior-Driven Development (BDD) as a software development process that emerged from Test-Driven Development (TDD). It explains that BDD encourages collaboration between developers, QA, and non-technical business participants by focusing on defining the desired 'behavior' of the system in a shared, understandable language."
  },
  {
    "n": 2,
    "title": "What Is Cucumber?",
    "math": "Domain-Specific Languages (DSLs)",
    "note": "This section introduces Cucumber as a tool that supports BDD. It explains that Cucumber acts as a bridge, translating plain-text specifications—written in a language called Gherkin—into executable tests that verify the system's behavior. The various language implementations (Java, JS, Ruby, etc.) are mentioned."
  },
  {
    "n": 3,
    "title": "Gherkin: The Language of Cucumber",
    "math": "Formal language syntax",
    "note": "This lesson introduces Gherkin, the simple, business-readable language used to write specifications in Cucumber. It is a line-oriented language that uses keywords to structure plain-text descriptions of software behavior, making it understandable for the whole team."
  },
  {
    "n": 4,
    "title": "Gherkin Keywords: `Feature` and `Scenario`",
    "math": "Specification structure",
    "note": "This section covers the basic structure of a Gherkin document, called a 'feature file'. It explains the `Feature` keyword, used to describe a high-level software feature, and the `Scenario` keyword, used to describe a concrete example of that feature's behavior."
  },
  {
    "n": 5,
    "title": "Gherkin Keywords: `Given`, `When`, `Then`",
    "math": "Pre-condition, Action, Post-condition",
    "note": "This lesson details the core steps used to define a scenario. It explains `Given` (to describe the initial context or pre-condition), `When` (to describe an event or action), and `Then` (to describe the expected outcome or post-condition). The keywords `And` and `But` are also introduced for continuing a previous step."
  },
  {
    "n": 6,
    "title": "Writing Your First Feature File",
    "math": "Technical writing",
    "note": "This lesson provides a practical guide to writing a simple feature file for a login feature. It demonstrates how to combine the `Feature`, `Scenario`, `Given`, `When`, and `Then` keywords to create a clear, readable specification for a single behavior."
  },
  {
    "n": 7,
    "title": "Step Definitions: Connecting Gherkin to Code",
    "math": "Function mapping",
    "note": "This section explains the concept of Step Definitions. A step definition is a piece of code (e.g., a Java or Ruby method) that is linked to a Gherkin step via a pattern. When Cucumber executes a Gherkin step, it calls the corresponding step definition method. This is how plain text becomes an automated test."
  },
  {
    "n": 8,
    "title": "The Red-Green-Refactor Cycle in BDD",
    "math": "Iterative development cycle",
    "note": "This section explains the workflow of BDD with Cucumber. 1. (Red) Write a scenario and run it to see the steps fail or be marked as pending. 2. (Green) Write the minimum amount of application and step definition code to make the scenario pass. 3. (Refactor) Clean up and improve the code while keeping the test passing."
  },
  {
    "n": 9,
    "title": "Reducing Duplication with `Background`",
    "math": "Code reuse",
    "note": "This lesson introduces the `Background` keyword in Gherkin. It is used to define a set of `Given` steps that are common to all scenarios within a single feature file. This avoids repetition and makes the feature file cleaner."
  },
  {
    "n": 10,
    "title": "Data-Driven Testing with `Scenario Outline`",
    "math": "Parameterized testing",
    "note": "This section covers how to run the same scenario with multiple different sets of data. It introduces the `Scenario Outline` keyword, which uses placeholders in the steps, and the `Examples` table, which provides the values to be substituted into the placeholders for each run of the scenario."
  },
  {
    "n": 11,
    "title": "Passing Data with Data Tables",
    "math": "Data structures (tables)",
    "note": "This lesson explains how to pass a structured table of data from a Gherkin step to a step definition. This is useful for providing more complex data than can fit in a single step line. The step definition then receives this data as a list of lists or a similar data structure."
  },
  {
    "n": 12,
    "title": "Capturing Arguments with Regular Expressions",
    "math": "String capturing groups",
    "note": "This section provides a dive into making step definitions flexible. It demonstrates how to use capturing groups with regular expressions to extract values from a Gherkin step and pass them as parameters to the step definition method (e.g., capturing a username from 'When the user \"admin\" logs in')."
  },
  {
    "n": 13,
    "title": "Modern Argument Capturing with Cucumber Expressions",
    "math": "Pattern matching",
    "note": "This lesson introduces Cucumber Expressions as a simpler, more readable alternative to regular expressions. It covers the built-in expression types like `{string}`, `{int}`, and `{float}`, showing how they make step definitions easier to write and understand for common cases."
  },
  {
    "n": 14,
    "title": "Organizing Features with Tags",
    "math": "Tagging systems",
    "note": "This lesson introduces Tags, which are annotations starting with the `@` symbol that can be placed above `Feature` or `Scenario`. Tags are used to categorize your tests (e.g., `@smoke`, `@regression`) and to selectively run only a subset of scenarios."
  },
  {
    "n": 15,
    "title": "Setup and Teardown with Hooks",
    "math": "Lifecycle hooks",
    "note": "This section explains Hooks, which are blocks of code that can run at various points in the Cucumber test cycle. It covers the `@Before` hook (which runs before each scenario) and the `@After` hook (which runs after each scenario). These are commonly used for tasks like setting up a database connection or closing a web browser."
  },
  {
    "n": 16,
    "title": "The Cucumber Command-Line Interface (CLI)",
    "math": "Command-line tools",
    "note": "This lesson covers how to run Cucumber from the command line. It explains how to specify which features to run by path, how to filter tests using tags (`--tags`), how to specify the location of step definitions (`--glue`), and how to choose different report formats (`--plugin`)."
  },
  {
    "n": 17,
    "title": "Generating Reports",
    "math": "Test reporting",
    "note": "This lesson covers how to generate human-readable reports from a Cucumber test run. It explains how to configure Cucumber to output reports in various formats, such as HTML for easy viewing, and JSON or XML for integration with CI/CD systems like Jenkins."
  },
  {
    "n": 18,
    "title": "Using Cucumber for Web Testing with Selenium",
    "math": "UI automation",
    "note": "This lesson provides a practical guide to integrating Cucumber with Selenium WebDriver. It explains how to set up the WebDriver in a `@Before` hook and then write step definitions that use the Selenium API to perform actions like navigating to a URL, finding elements, clicking buttons, and asserting on page content."
  },
  {
    "n": 19,
    "title": "The Page Object Model (POM) with Cucumber",
    "math": "Design patterns",
    "note": "This section introduces the Page Object Model (POM) as a design pattern for creating maintainable UI tests. It explains how to create classes that represent pages of the application, encapsulating the selectors and methods for interacting with that page. These page objects are then used within the step definitions to keep them clean and readable."
  },
  {
    "n": 20,
    "title": "Using Cucumber for API Testing",
    "math": "API testing",
    "note": "This lesson demonstrates how Cucumber can be used to test REST APIs. It shows how to write Gherkin scenarios that describe API behavior (e.g., 'When I send a POST request to /users'). The step definitions are then implemented using an HTTP client library to make the requests and assert on the status codes and response bodies."
  },
  {
    "n": 21,
    "title": "Advanced State Management with Dependency Injection",
    "math": "Dependency injection",
    "note": "This lesson tackles the problem of sharing state between steps in a clean way. It introduces the concept of Dependency Injection (DI) and shows how Cucumber can integrate with a DI container (like PicoContainer for Java) to create, manage, and inject shared state objects into step definition classes."
  },
  {
    "n": 22,
    "title": "The Philosophy of Living Documentation",
    "math": "Agile communication",
    "note": "This final lesson reinforces the core purpose of BDD and Cucumber. It explains the concept of 'Living Documentation': a suite of feature files that serves as an accurate, up-to-date, and easy-to-read specification of the system's behavior, because it is automatically and continuously verified against the actual system."
  }
]
